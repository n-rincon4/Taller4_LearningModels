# -*- coding: utf-8 -*-
"""Taller 4 - Robotics Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vhc_hdXfWQv0Fay0wObHC0e97nmA52bT

# Punto 1 - Red Convolucional

Para trabajar con la red neuronal convolucional, se utiliza el Framework Tensorflow, junto con las librerías Numpy, MatPlotLib y OpenCV.
"""

import tensorflow as tf

import numpy as np
import matplotlib.pyplot as plt
import math

import cv2
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.preprocessing import image

"""Se utiliza un subconjunto de datos del fichero "Nivel 1_Test" y "Nivel 8_Test" pertenencientes al conjunto de datos obtenidos desde el repositorio. Como cada uno de estos ficheros contiene aproximadamente 1000 imágenes, se toma el 4% de estas; es decir, 40 imágenes para cada nivel."""

# Hiperparámetros
batch_size = 32
num_classes = 2
epochs = 60
input_shape = (32, 32, 3)
clases = ["Nivel 1", "Nivel 8"]

# Generar el conjunto de datos de entrenamiento y de prueba
train = ImageDataGenerator(rescale=1/255)
test = ImageDataGenerator(rescale=1/255)

train_dataset = train.flow_from_directory("/content/train",
                                          target_size = (32,32),
                                          batch_size = 4,
                                          class_mode = "binary")

test_dataset = test.flow_from_directory("/content/test",
                                          target_size = (32,32),
                                          batch_size = 100,
                                          class_mode = "binary")

train_dataset.class_indices

test_dataset.class_indices

"""Se utiliza el patrón de capas Convolucional-Pooling. Se diseña una red de 7 capas. Se compone de dos capas Conv2D, MaxPooling, seguidas de una capa Flatten, una capa Dense de 100 neuronas y una capa Dense de 2 neuronas de salida."""

# Definir el modelo convolucional
modelo = tf.keras.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), input_shape=input_shape, activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(units=512, activation='relu'),
    tf.keras.layers.Dense(units=1, activation='sigmoid')
])

modelo.summary()

"""Compilar el modelo de la red"""

#Compilar el modelo
modelo.compile(
    optimizer="adam",
    loss="binary_crossentropy",
    metrics=['accuracy']
)

"""Entrenar la red neuronal"""

#Realizar el entrenamiento
historial = modelo.fit(
    train_dataset,
    epochs=epochs,
    steps_per_epoch=math.ceil(10)
)

plt.xlabel("# Epoca")
plt.ylabel("Magntiud de Pérdida")
plt.plot(historial.history["loss"])

# Corroborar las predicciones de la red
import os

nivel1_dir = "/content/test/nivel1"

resultados_nivel1 = []
for i in os.listdir(nivel1_dir):
  img = image.load_img(nivel1_dir + "//" + i, target_size=(32,32))
  plt.imshow(img)
  plt.show()

  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)
  images = np.vstack([x])
  valor_predicho = modelo.predict(images)

  if valor_predicho == 0:
    print(i + " es una fotografía del NIVEL 1")
    resultados_nivel1.append(1)
  else:
    print(i + " es una fotografía del NIVEL 8")
    resultados_nivel1.append(8)

nivel8_dir = "/content/test/nivel8"

resultados_nivel8 = []
for i in os.listdir(nivel8_dir):
  img = image.load_img(nivel8_dir + "//" + i, target_size=(32,32))
  plt.imshow(img)
  plt.show()

  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)
  images = np.vstack([x])
  valor_predicho = modelo.predict(images)

  if valor_predicho == 0:
    print(i + " es una fotografía del NIVEL 1")
    resultados_nivel8.append(1)
  else:
    print(i + " es una fotografía del NIVEL 8")
    resultados_nivel8.append(8)

# Estadísticas de predicción para el Nivel
def aciertos_nivel(nivel:int, vector_resultados:list):
  imagenes_correctas = 0
  imagenes_totales = len(vector_resultados)
  if nivel == 1:
    imagenes_correctas = vector_resultados.count(1)
  else:
    imagenes_correctas = vector_resultados.count(8)

  porcentaje_acierto_nivel = imagenes_correctas/imagenes_totales
  return str(porcentaje_acierto_nivel)

print("El porcentaje de acierto para el Nivel 1 es " + aciertos_nivel(1,resultados_nivel1))
print("El porcentaje de acierto para el Nivel 8 es " + aciertos_nivel(8,resultados_nivel8))
